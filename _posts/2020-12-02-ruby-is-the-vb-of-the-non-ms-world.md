---
title: Ruby is the VB of the non-Microsoft world
tags: [ruby, opinion]
---

# {{ page.title }}

After almost 10 years of working in online gaming it is time to go and work on a completely different domain (medicine) using my favorite tech of the last 5 years: Elixir. But like most shops doing Elixir, this next one I'm going to be working with has started out with Ruby, and so it made sense to catch up to Ruby as it's almost certain I'll have to work with it sooner rather than later. For this I'm following [The Well-Grounded Rubyist, 3rd edition](https://www.manning.com/books/the-well-grounded-rubyist-third-edition) book[^1] my new colleagues suggested.

I'm about to share my thoughts, having read all of a half of a single book on Ruby and feeling enough of an 'expert' to write my not-so-flattering opinions on a language that is loved by many and powers some of the [largest software businesses](https://rubygarage.org/blog/the-best-websites-built-with-ruby-on-rails) today. Reckless, no? Or at the very least _really_ cocky. Well, I'm feeling confident today, what can I say ;)[^2]. And I'm also feeling frustrated and confused with what I've learned and came to understand about the language- so much in fact that I decided to stop my reading for now and write this post to vent.

To better understand my impressions of Ruby, I'll set the stage by talking a little about VB first. Now, VB is [neither the best known nor the most loved tech](https://insights.stackoverflow.com/survey/2020#most-popular-technologies) out there[^3], but coming from the .NET world of software originally, I have had the chance to both marvel at and swim inside the marvelous soup of a language that VB is. You see VB was created to cater to line-of-business type of software development first and foremost. So the barrier to entry was set as low as possible to enable people to write _some_ software to accelerate/automate their business. And the decisions that Microsoft made for the language were focused on just this kind of development mindset- i.e. make sh\*t easy to write _right now_ and worry about maintainability later[^4]. But those decisions eventually caught up to them, having caused enough pain for the official documentation to change and strongly suggest for new projects to set the `Option Strict On` and `Option Explicit On` flags right from the start. In fact 'safety off' and other similar easy-to-start-but-hard-to-maintain hacks were so harmful that led to the language's eventual [extinction](https://visualstudiomagazine.com/articles/2020/03/12/vb-in-net-5.aspx). Yeap, investing in learning VB now sounds like a sure bet for the future.

All right then, let's talk Ruby. So what does Ruby optimize for? Up until now I've only heard anecdotal references about Ruby and the greater Ruby ecosystem, and the single most prominent point was always "developer productivity"; followed closely by "beautiful syntax". F\*ck. Beautiful syntax? How can this be a prime directive for language design? I've never heard of a more shallow primary goal for a language to have in my entire life. I mean, yes, to hope for mass adoption a language should be designed in such a way that the syntax at the very least isn't abhorrent (or too [unfamiliar](https://www.youtube.com/watch?v=QyJZzq0v7Z4)). But taking this to extremes, making it one of the most important values in a language's design must surely lead to compromises elsewhere- like maintainability, speed and consistency to mention but a few. And sure enough, performance takes a hit, and I'll talk about some of that. But the thing that jumps at me from reading up on Ruby is the cost of maintainability- and thus developer productivity. Because I'm convinced that nothing can survive this single-minded pursuit of superficial beauty. Walk with me:

First up is __object-itis__. Ruby suffers from a particularly bad case of this disease. It's not alone of-course in that, but other languages I've come across do at least differentiate between value-types and reference-types, and part (a big part!) of the reason is of course speed. Not so with Ruby- elegance dictates everything be an object, no exceptions, even integers. Stuff that should take just a few bytes on the stack now have to be [stored and de-referenced from the heap](https://stackoverflow.com/questions/13639166/in-ruby-what-is-stored-on-the-stack) because they carry a ton of baggage with them. Is it cool that `int`s are modelled the same[^5] as e.g. `Person`s are? In my opinion, no. To get this kind of homogeneity Ruby sacrifices low-hanging, no-brainer performance opportunities while at the same time going essentially against the grain: most programmers coming to Ruby would know about this difference already and would not spend extra mental effort to understand it. But then it is consistent with Ruby's goals of uncompromising 'beauty' and 'elegance'- ideals that Ruby is willing to sacrifice almost anything to.

So then to get back some sense of usability and performance, Ruby decided to offer __mutable strings__. Is this beautiful? Not per se, it doesn't directly serve Ruby in terms of beauty. But it doesn't directly hurt Ruby's shallow perception of external beauty either, so in Ruby's book it's OK to pursue mutability in strings to try and gain some performance back. If you've ever read anything about compiler and runtime design choices when it comes to strings (and I'm definitely not an expert- only curious about stuff on the internets), then you've definitely come across some interesting discussions on trade-offs like pascal vs null-terminated strings, reference counted vs value-copied, UTF-8 vs UCS-2 underlying representations, string equality and a ton of others. But I just can't remember the last time I read anywhere a debate about making strings mutable (except in lower level languages where anything goes) as the downsides of mutation are so severe that it just isn't worth it- like in the case of GC and multi-threading. Except in Ruby land speed is not a goal- except again in the case of strings where Ruby _is_ forced after all to do something about performance. Ruby with it's mania of good-lookin' code has painted itself into a corner and now has to introduce workarounds to get out of it. But this makes future matters worse in at least two ways that I can see: an implementation that introduces proper multi-threading (or erlang-style green threading or whatever) and does away with the GIL becomes near impossible, and long-term maintainability of any large code base will suffer because one can just never be sure that some string value that they've read off the network will remain what it was when it was first assembled from incoming bytes; weird bugs will be popping up all over that will cost in maintenance time- and thus developer productivity. That's right, for an ecosystem that puts productivity first, it sure does look like it's sending some mixed signals there.

Since we're on the topic of strings... again, wtf Ruby? Who in their right mind decided that __[String#crypt](https://www.rubydoc.info/stdlib/core/String:crypt) is core-enough functionality__ to warrant putting it in the String hierarchy Ruby ships with? Going through the docs one can see so many gotchas with that decision: an outdated encryption scheme, an API design that makes it easy to introduce security vulnerabilities because of bad salt practices and a direct push to use this instead of more modern algorithms (it's in the core after all, isn't it?) when it probably shouldn't be used at all. It's obvious that whoever put it there only had a very short-sighted view of cryptography practices a bad taste in basic API design, optimising for short term wins "oh man, encrypting strings this way is so easy and convenient, isn't it?" over longer term goals like maintainability. And now you can perhaps more clearly see why I'm reminded of VB: short-term conveniences seem to drive decisions, even over what is arguably common sense in API and language design: once something is put in, it can never be removed and can only seldomly change behavior/semantics because of the dependencies devs will now have on the thing.

Before I let `String` off the hook I'd like to mention another cute little gem in there: [String#next](https://www.rubydoc.info/stdlib/core/String#next-instance_method). `String#next` is offensive in almost all the ways that crypt is, like who decided that calculating the lexicographically next string should go into the core and that it should be limited to a mostly alphanumeric subset of the ASCII character set, which in turn is by no means made explicit by the API (one needs to open the docs to find out ~~all~~ most of the sneaky little gotchas). But `next` stands out for one more reason: it is __aliased to `succ`__. I'm gonna go out on a leg here and try to think of a reason for this with my Ruby hat on: I believe that the reason next is aliased to succ and that this aliasing is part of the core API, is because it makes for _better prose_ when writing code. That's right, I said it: it's probably because with the right combination of preceding variables and methods `#succ` looks better in some cases than `#next`. Never mind that by mindlessly and superficially increasing the API surface, Ruby also increases the chances of someone knowing just one of the two variants about the same thing- and thus making sure that time will be spent on trying to find out what this other thing is. Is this productive for developers? Doesn't feel like it is.

This pursuit of __prose-like__ like code-writing is everywhere: there's unless for if-nots, there's untils for while-nots, there's end-of-statement conditional operators for control blocks, message sending for method-calling, do-ends for curlies, code blocks for lamdas and a ton of other examples of if things can be done in more than one ways then Ruby has them all, each with slightly different semantics to make things spicier. Yum. I love me some variety.

Do I need to continue this tirade of bashing on Ruby? Do you need me to talk about the deep class hierarchies and the overweight API of just about every single aspect of the language? How about the duality of inheriting vs. mixing-in modules? The constants being not constants? Or about the fact that it's apparently accepted practice in Ruby to carelessly open up a class definition and throw some extra few new methods in there for all instances, both new and existing, to instantly have access to? Come on, even javascript got that one right in the end: adding your crap on String.prototype is bad and should be avoided. And there's still more, like the obsession with creating new Exception types to throw (yeay! exception-tennis control flow!), the unsanitized macros etc. But I think you get my point. I'm not enchanted.

So why did I feel the need to rant? I'm no longer a kid driven by passions and strong opinions, why vent about a language I haven't even written anything in it yet? It's because Ruby reeks of a cowboy attitude, seemingly playing fast and loose with everything that matters in a language for well-structured codebases. Modern languages have this concept of leading programers into "__the pit of success__", i.e. make unintended usage of features and bad representations difficult so that devs following the path of least resistance are sure to end up doing the right thing- even when they're clueless juniors. Not so with Ruby. Everything I've seen is edge cases and bad design, setting traps everywhere for hapless devs to fall into[^6]. Ruby is not performant (never claimed to be) but it's not productive either. My best guess is that Rails made writing CRUDs in Ruby productive, much like Laravel brought sanity to php development, and that productivity rubs off on Ruby as well- undeserving as I find it to be of this badge.

As always, basing your decision for which technology to pick on random, very possibly flawed and severely uninformed opinions of strangers on the internet is not considered best practice; this principle applies here as well. If you're already into Ruby you may as well continue enjoying it as chances are you've already paid for the admission cost and are mostly aware of the pitfalls. But I'm not sure that for devs looking to learn something new Ruby is a good choice. Good ideas in Ruby have been copied in newer languages, but Ruby is now left to deal with the mess it created for itself, and you shouldn't have to shoulder it too.

PS. Are there any redeeming qualities in Ruby? By my estimate, it has probably influenced modern languages in that languages can afford and do put some effort in designing nice-looking APIs and conveniences. And if it wasn't for his frustration with Ruby, Jose Valim never would have made Elixir, so thank you Ruby!

[^1]: I find that when I'm trying to learn a new piece of tech nothing can beat a good book in terms of introducing new concepts in an organized manner.

[^2]: Even though I haven't written any Ruby code, I must rely on my experiences from other languages, tools and frameworks to inform my opinions on stuff before I commit to using and shipping them and then taken aback by the pain of supporting them in production.

[^3]: When I say VB I'm kind of generalizing and putting all of the VB* variants in the same bag- VB, VBA and VB.NET. Is this unfair? Possibly, but not to a degree that matters for the points raised here.

[^4]: In this [Eric Lippert blog post](https://ericlippert.com/2020/02/27/hundred-year-mistakes/) (one of the most influential people in the C# ecosystem) he famously talks about VB and their decision to make XML creation a core language feature (it's in the comments section).

[^5]: Default rules for ints aren't really the same as for other objects, are they? The integer 100 for example is made into a singleton object stored somewhere on the heap, and every new occurence of the same number refers to that same instance to avoid generating too many garbage for the poor GC to collect.

[^6]: Ruby having all these millions of ways of doing the same thing also reminds me of the [photoshop file format](https://github.com/gco/xee/blob/master/XeePhotoshopLoader.m#L108) and [php](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/)- from the old days of php 5.2/5.3 when classes were introduced but the documentation insisted everywhere that "php is not and never will be an OO language". But, but... there's classes man. Oh well.
